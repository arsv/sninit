Overview
~~~~~~~~
sninit is a small init implementation for linux.

It is meant to be a cleaner and more reliable replacement
for sysvinit/initscripts combo, providing better control over
foreground processes and removing the need for initscripts.

Alternatively, it is a much much smaller systemd replacement
for systems that need basic systemctl but would rather avoid
bringing in enormous systemd bundle.

sninit is written mostly in raw syscalls and has no external
dependencies â€” not even libc. On supported architectures it
gets built into a statically-linked, self-contained executable. 


Key features
~~~~~~~~~~~~
+ Runlevels for process management
+ Starting/stopping individual processes manually
  "telinit stop httpd" and so on
+ Sleep/suspend/hibernate as runlevels
+ Support for initdirs (one file per process),
  in addition to sysvinit inittab (one line per process)
+ Small size and static linkage
+ Simplified memory management;
  no malloc, memory allocation only while reconfiguring

Missing features:

- built-in system state management (network/mounts/sysconfig/ulimits)
- inter-process dependencies, systemd-style
- support for kernels other than linux-2.6+
- dbus, xml and other bloat
- wall(8), shutdown(8) and some other sysvinit-style utilities
- in-place restarting a-la sysvinit

Features sninit has that are not in any way exceptional:

* parallel startups
  (busybox init allows it, never mind sysvinit)


What is init
~~~~~~~~~~~~
init is process 1 in Linux and other Unix-like systems.

Upon booting itself, kernel only starts one process, typically /sbin/init.
This process is expected to initialize the system and start everything else,
including user interface.
This process is not expected to exit; in case it does, kernel panic happens.

Init starts several processes in sequence, waiting for them to finish,
mounting filesystems, initializing devices and so on.
Once the system is ready, init starts daemon-like processes, and keeps
respawning them in case they die.

Daemon-like processes usually include getty (with login as a subprocess),
xinit or X display manager, as well as actual daemons in foreground mode.


Building sninit
~~~~~~~~~~~~~~~
For proper build instructions, see INSTALL file.

To try sninit without configuring a VM or installing anything:

	./configure devel
	make
	./init
	(from another terminal)
	./telinit list
	./telinit stop srv1
	./telinit sleep
	./telinit reload
	./telinit poweroff

In this configuration, init uses ./etc/inittab, ./etc/initdir
and stub executables from ./sbin.

For further trials and testing, check doc/buildroot.txt.


Just how small exactly?
~~~~~~~~~~~~~~~~~~~~~~~
Typical size of statically-linked, stripped executables for different
architectures:
                     init     telinit    run
        x86          14KB       3KB      5KB
        x86_64       15KB       3KB      6KB
        arm          17KB       4KB      7KB
        arm64        17KB       3KB      6KB
        mips         25KB       4KB     10KB

telinit is a standalone executable in sninit, not a hardlink to init.
run is optional, and not really related to init at all.


Credits
~~~~~~~
sninit draws ideas from busybox init, minit and the original sysvinit.

"No-malloc" approach to memory management was inspired by rockbox,
though in rockbox itself it was done in a different way.

Small size and static linkage are mostly due to dietlibc and busybox.
See "Writing Small and Fast Software" by Felix von Leitner.


Licensing
~~~~~~~~~
GPLv3, see COPYING file.


Author
~~~~~~
Alex Suykov <alex.suykov@gmail.com>
