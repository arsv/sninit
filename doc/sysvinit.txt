Migrating from sysvinit
~~~~~~~~~~~~~~~~~~~~~~~
sninit uses almost the same inittab syntax as sysvinit.

	name:runlevels:flags:command

There are some differences though, explained below.


Flags
~~~~~
In sysvinit "flags" field is called "action", and it is always a single word.
In sninit, it's a comma-separated list of process flags.
Still, most sysvinit actions translate easily into sninit flags:

	respawn
		accepted but ignored, respawning is the default mode for sninit
	wait
		leave as is
	once
		leave as is
	boot
		sninit equivalent is name::once:command,
		that is, *empty* runlevels and "once" for action.
	bootwait
		sninit equivalent is name::wait:command,
		again, with empty runlevels field.
	off
		leave as is. In sninit, the process still can be started with
		"telinit start name". With no wait or once, implies respawn. [TODO]
	ondemand
		remove, leaving secondary runlevels in the runlevels field.
		That is, name:ab:ondemand:command becomes name:ab::command.
		With no additional flags, implies "respawn".
	initdefault
		not supported, specify desired runlevel in kernel command line.
	sysninit
		not supported, replace with "name::wait" and place somewhere
		near the top of inittab.
	powerwait
	powerfail
	powerokwait
	powerfailnow
		not supported, use runlevels and telinit to switch them.
	ctrlaltdel
		not supported. Upon receiving SIGINT, sninit will start switching
		to runlevel 0, rebooting the system once it's there.
	kbrequest
		not supported, sninit ignores SIGWINCH


Runlevels
~~~~~~~~~
In sninit, w-type and o-type entries ("wait" and "once" respectively) are only
started in-between runlevels, i.e. when moving from runlevel N to runlevel M.
Services, or s-type entries ("respawn") are started during the switch, but may
be restarted later when init has already settled in runlevel M.

Mixing primary (0123456789) and secondary (aka ondemand, abcdef) runlevels is allowed;
"23a" means "run on / when entering runlevels primary runlevels 2 or 3, but ONLY if
secondary runlevel a is activated". The rules for o-/w-type entries still hold though,
so telinit +a will not start a "23a:wait" entry if init is in runlevel 2 or 3 already.
On the other hand, s-type entries will be started immediately.

While in sysvinit runlevels 0 and 6 were special mostly by convention, in sninit
reaching runlevel 0 prompts a reboot(2) call and runlevel 6 should not be special
in most sane configurations. Both halt, reboot and poweroff use runlevel 0, the
only difference being the argument passed to reboot(2) in the end.

Runleves 789 are allowed in sninit, but they are "slippery" unless configured otherwise.
That is, upon reaching any of these runlevels, init will immeditely start a switch back
to the last non-slippery runlevel it was in.
This is to allow sleep/suspend to be implemented as runlevels.


Commands
~~~~~~~~
For interactive processes, use "tty" flag. Conventional "-command" does not work.

If you want a command to be spawned via sh -c "command", request it
explicitly: "!command". Unlike sysvinit, sninit does not spawn processes
via shell just because there are unusual characters in the command.


Names
~~~~~
name field in sninit is longer than in sysvinit. Names are not
checked for uniqueness, but generally you want to keep them unique.

Entry names are also used for logging, sysvinit does not do it.


Reboot and friends
~~~~~~~~~~~~~~~~~~
In sninit, reboot, poweroff and halt are all runlevel 0, which is assumed
to mean "stop everything".  Also, there are no reboot, poweroff and halt commands;
use telinit reboot, telinit poweroff and telinit halt instead.


Signals
~~~~~~~
sninit does not reload configuration on SIGHUP, use telinit q instead.
This is mostly because of error reporting, telinit q will show errors while
SIGHUP will leave them in syslog.

In sninit, SIGHUP works just like SIGUSR1 in sysvinit, forcing init to reopen
its control socket. Should be useless as long as said socket is @initctl, but
for /dev/initctl, it may be necessary.

sninit ignores SIGWINCH. No replacement as this point, it is just ignored.

sninit handles SIGINT somewhat differently due to different approach to rebooting.
Still, the end result should be exactly the same, Ctrl-Alt-Del, if allowed
to reach init, will cause the system to reboot.
